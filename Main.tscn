[gd_scene load_steps=2 format=3 uid="uid://dfo4aealsw6va"]

[sub_resource type="GDScript" id="GDScript_rxg2q"]
resource_name = "Main"
script/source = "extends Control

@export var sample : Texture2D = preload(\"res://samples/City.png\")
@export var tile_size := Vector2i.ONE * 3
@export var cell_grid_size := Vector2i(30, 10)
@export var cell_draw_size := Vector2i(10, 10)

var sample_padded : Image
var sample_padded_tex : ImageTexture
var sample_size : Vector2i
var tiles : Array[Tile] = []
var cells : Array[Cell] = []
var collapsed_count := 0
var default_font : Font = ThemeDB.fallback_font;

var run := false

func _ready():
	#seed(69421)
	
	var sample_image := sample.get_image()
	sample_size = Vector2i(sample.get_size())
	
	var padded_size := sample_size + tile_size - Vector2i.ONE
	
	sample_padded = Image.create_empty(padded_size.x, padded_size.y, false, sample_image.get_format())
	sample_padded.fill(Color.DEEP_PINK)
	
	var repeats := padded_size / sample_size + Vector2i.ONE
	
	for i in range(repeats.x):
		for j in range(repeats.y):
			sample_padded.blit_rect(sample_image,
				Rect2i(Vector2i.ZERO, sample_size),
				Vector2i(i * sample_size.x, j * sample_size.y))
				
	sample_padded_tex = ImageTexture.create_from_image(sample_padded)
	
	var total := sample_size.x * sample_size.y
	for j in range(sample_size.y):
		for i in range(sample_size.x):
			var idx := j * sample_size.x + i
			var tile := Tile.new(i, j, idx, sample_padded, tile_size, total)
			
			tiles.append(tile)
	
	for tile in tiles:
		tile.fill_neighbors(tiles)
		
	for r in cell_grid_size.y:
		for c in cell_grid_size.x:
			var cell := Cell.new(len(tiles))
			cells.append(cell)
	
func _draw():
	var rid := get_canvas_item()
	var gap := 0.

	for i in len(cells):
		var cell := cells[i]
		var grid_pos := pos_from_idx(i, cell_grid_size.x)
		var pos = Vector2((cell_draw_size.x + gap) * grid_pos.x, (cell_draw_size.y + gap) * grid_pos.y)
		
		if len(cell.options) <= 0:
			draw_rect(Rect2(pos, cell_draw_size), Color.DEEP_PINK)
		elif not cell.collapsed:
			var t := float(len(cell.options)) / float(len(tiles))
			draw_rect(Rect2(pos, cell_draw_size), Color.WHITE.lerp(Color.BLACK, t))
			
			# draw_string(default_font, pos + rect_size/2, \"%02d\" % len(cell.options),
			# 	HORIZONTAL_ALIGNMENT_LEFT, 90, 20, Color.WHITE if t > 0.5 else Color.BLACK)
		else:
			var tile := tiles[cell.options[0]]
			#tile.draw(rid, pos, rect_size)
			var col = tile.image.get_pixelv(tile_size / 2)
			draw_rect(Rect2(pos, cell_draw_size), col)
	
func _input(event):
	#if not Input.is_action_just_pressed(\"step\") or collapsed_count >= len(cells):
	#	return
	
	if event.is_action_pressed(\"run\"):
		run = not run
	elif event.is_action_pressed(\"reset\"):
		run = false
		collapsed_count = 0
		
		for cell in cells:
			cell.full_reset(len(tiles))
		
		queue_redraw()

func _process(delta):
	if collapsed_count >= len(cells) or not run:
		return
		
	wfc_step()
	queue_redraw()
		
func wfc_step():
	var cells_idxs : Array[int]= []
	
	for idx in len(cells):
		var cell := cells[idx]
		
		if cell.collapsed:
			continue
		
		cell.stepped = false
	
		if len(cell.options) > 0:
			cells_idxs.append(idx)
		else:
			printerr(\"Conflict!\")
			run = false
	
	if len(cells_idxs) <= 0:
		printerr(\"No collapsable cells!\")
		run = false
		return
	
	cells_idxs.sort_custom(func(ia: int, ib: int):
		var la := len(cells[ia].options)
		var lb := len(cells[ib].options)
		
		# if la == lb:
		# 	return ia < ib
		
		return la < lb
	)
	
	var target : int = cells_idxs.slice(0, 4).pick_random()
	var target_cell := cells[target]
	var propagate_depth = 6
	
	target_cell.collapse()
	collapsed_count += 1
	
	# print(\"Collapsed cell %d at %s to %d\" % [
	# 	target, pos_from_idx(target, cell_grid_size.x), cells[target].options[0]
	# ])
	
	propagate(target, propagate_depth)

func propagate(current_idx: int, max_depth: int):
	var current := cells[current_idx]
	
	if max_depth <= 0:
		return true
		
	current.stepped = true
	
	for side_key in Tile.TILE_SIDE.keys():
		var side : Tile.TILE_SIDE = Tile.TILE_SIDE.get(side_key)
		var neighbor_idx := side_cell(current_idx, side)
		
		if neighbor_idx < 0:
			continue
			
		var neighbor := cells[neighbor_idx]
	
		if neighbor.collapsed:
			continue
			
		var valid : Array[int] = []
		for opt in current.options:
			valid.append_array(tiles[opt].neighbors[side])
			
		neighbor.options = neighbor.options.filter(func(tile_idx):
			return tile_idx in valid
		)
		
		propagate(neighbor_idx, max_depth-1)

func side_cell(origin_idx: int, side: Tile.TILE_SIDE, clamp := true) -> int:
	var origin_pos := pos_from_idx(origin_idx, cell_grid_size.x)
	var dest_pos := origin_pos
	
	match side:
		Tile.TILE_SIDE.NORTH:
			dest_pos.y -= 1
		Tile.TILE_SIDE.SOUTH:
			dest_pos.y += 1
		Tile.TILE_SIDE.EAST:
			dest_pos.x -= 1
		Tile.TILE_SIDE.WEST:
			dest_pos.x += 1
	
	if clamp:
		if dest_pos.x >= cell_grid_size.x or dest_pos.y >= cell_grid_size.y:
			return -1
		if dest_pos.x < 0 or dest_pos.y < 0:
			return -1
	
	var dest_idx := idx_from_pos(dest_pos.y, dest_pos.x, cell_grid_size.x)
	
	if dest_idx >= len(cells):
		dest_idx = -1
	
	return dest_idx

func idx_from_pos(row: int, col: int, width: int) -> int:
	return -1 if (row < 0 or col < 0) else row * width + col
	
func pos_from_idx(idx: int, width: int) -> Vector2i:
	return Vector2i(idx % width, floori(idx / width))

func get_sample_section(top_left: Vector2i, extents: Vector2i) -> Image:
	var img := sample_padded.get_region(Rect2i(top_left, extents))
	
	return img
"

[node name="Control" type="Control"]
texture_filter = 1
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = SubResource("GDScript_rxg2q")
cell_grid_size = Vector2i(70, 50)
